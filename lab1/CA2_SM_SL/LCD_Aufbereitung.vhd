-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Generated by Quartus II Version 4.2 (Build Build 178 01/19/2005)
-- Created on Tue May 31 20:44:26 2005

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
use work.ca2_sm_package.all;
--
--  Entity Declaration
--  (C) 2013 R. Keller, W. Lindermeir und W. Zimmermann
--
ENTITY LCD_Aufbereitung IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		clk : IN STD_LOGIC;
		HW_Reset : IN STD_LOGIC;
		LCD_ready : IN STD_LOGIC;
		Tim_msec : IN STD_LOGIC_VECTOR(9 downto 0);
		Tim_sec : IN STD_LOGIC_VECTOR(5 downto 0);
		Tim_min : IN STD_LOGIC_VECTOR(5 downto 0);
		Tim_hour : IN STD_LOGIC_VECTOR(9 downto 0);
		refresh : OUT STD_LOGIC;
		LCD_data : OUT STD_LOGIC_VECTOR(255 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
END LCD_Aufbereitung;


--  Architecture Body

ARCHITECTURE LCD_Aufbereitung_architecture OF LCD_Aufbereitung IS
   SIGNAL LifeSign   : std_logic_vector(7 downto 0);
   SIGNAL FF_Enable  : std_logic;
   SIGNAL HW_Reset_n : std_logic;

   -- Wandelt StdLogicVector in Natural
   pure function stdlogic_to_natural (SLV: in Std_Logic_Vector) return natural is
      variable result : natural := 0;
   begin
      for index in SLV'range loop
           result := result * 2 + Std_Logic'pos(SLV(index));
      end loop;
      return result;
   end function stdlogic_to_natural;

   -- Wandelt einen CHAR in ein ASCII-Zeichen
   pure function char2ascii ( char : in character ) return std_logic_vector is
   begin
      return std_logic_vector( to_unsigned(character'pos(char), 8));
   end function char2ascii;

   -- Wandelt einen 4-Bit-Dual-Wert (BCD) in ein ASCII-Zeichen
   pure function hex2ascii (nibble : in natural )
      return std_logic_vector is
      variable ret : std_logic_vector(7 downto 0);
   begin
      case nibble is
          when 0  => ret := char2ascii('0');
          when 1  => ret := char2ascii('1');
          when 2  => ret := char2ascii('2');
          when 3  => ret := char2ascii('3');
          when 4  => ret := char2ascii('4');
          when 5  => ret := char2ascii('5');
          when 6  => ret := char2ascii('6');
          when 7  => ret := char2ascii('7');
          when 8  => ret := char2ascii('8');
          when 9  => ret := char2ascii('9');
          when 10 => ret := char2ascii('A');
          when 11 => ret := char2ascii('b');
          when 12 => ret := char2ascii('C');
          when 13 => ret := char2ascii('d');
          when 14 => ret := char2ascii('E');
          when 15 => ret := char2ascii('F');
          when others => ret := char2ascii('E');
      end case;
      return ret;
   end function hex2ascii;

   -- Wandelt 1 Bit in ein ASCII-Zeichen (0 oder 1)
   pure function bit2ascii (input_bit : in std_logic) return std_logic_vector is
      variable ret : std_logic_vector(7 downto 0);
   begin
      case input_bit is
         when    '0' => ret := char2ascii('0');
         when    '1' => ret := char2ascii('1');
         when others => ret := char2ascii('0');
      end case;
      return ret;
   end function bit2ascii;

   -- Wandelt letzte 4-Bit eines Std_Logic_Vectors in BCD-Ziffer
   pure function INT2BCD_Stelle_0 (z : in natural) return std_logic_vector is
      variable ret : std_logic_vector(7 downto 0);
      variable Ziffer_int: natural;
   begin
      -- Rest von z bei Division durch 10 ermitteln
      Ziffer_int := z rem 10;
      -- Ziffer als ASCII-Code zurueckgeben
      ret := hex2ascii(Ziffer_int);
      return ret;
   end function INT2BCD_Stelle_0;
   --
   -- Wandelt Std_Logic_Vector als unsigned in Integer um.
   pure function SLV2NAT (in_SLV : in std_logic_vector) return natural is
   begin
      -- std_logic_vector als unsigned in Integer casten
      return to_integer(unsigned(in_SLV));
   end function SLV2NAT;
BEGIN

   -- Generieren eines Startzeichens fuer den LCD Controller
   refresh  <= '1' when (LCD_ready = '1') else '0';

   -- Takt-Gating fuer LifeSign
   HW_Reset_n <= not HW_Reset;
   MOD_CLK_inst: entity work.Mod_Counter
                 generic map(n => 25000000)
                 port map (clk => clk, PUReset_n => HW_Reset_n, OVF => FF_Enable);
   LifeSignP: PROCESS (clk, HW_Reset)
   BEGIN
      if (HW_Reset = '1') then
         Lifesign <= char2ascii('^');
      elsif (clk'event and (clk = '1')) then
         if ( FF_Enable = '1' ) then
              Case (LifeSign) is
                  when ("01011110")  =>  Lifesign <= char2ascii('>');      -- '^' --> '>'
                  when ("00111110")  =>  LifeSign <= char2ascii('v');      -- '>' --> 'v'
                  when ("01110110")  =>  LifeSign <= char2ascii('<');      -- 'v' --> '<'
                  when ("00000000")  =>  LifeSign <= char2ascii('^');      -- '<' --> '^'
                  when others        =>  LifeSign <= char2ascii('^');
              end case;
         end if;
      end if;
   END PROCESS LifeSignP;

   -- Obere Zeile:  "ZEIT:           "
   -- Hier: die ersten 16 Zeichen = 16x8 Bit
   LCD_data(255 downto 128) <=
   -- "Zeit: " 6 Z
   char2ascii('Z') & char2ascii('e') & char2ascii('i') & char2ascii('t') & char2ascii(':') & char2ascii(' ')
   -- Rest: Leerzeichen
   & char2ascii(' ') & char2ascii(' ') & char2ascii(' ') & char2ascii(' ') & char2ascii(' ') & char2ascii(' ')
   & char2ascii(' ') & char2ascii(' ') & char2ascii(' ') & LifeSign;
   
   -- Untere Zeile: "  hh:mm:ss,ttt"
   --
   LCD_data(127 downto 0) <=
            char2ascii(' ') --& char2ascii(' ')
            -- Stunden: 2-stellige BCD + ":"
            -- Zeichen 119..96
            & INT2BCD_Stelle_0((SLV2NAT(Tim_hour)/100))& INT2BCD_Stelle_0(SLV2NAT(Tim_hour)/10)
            & INT2BCD_Stelle_0(SLV2NAT(Tim_hour)) & char2ascii(':')
            -- Minuten: 2-stellige BCD + ":"
            -- Zeichen 87..72
            & INT2BCD_Stelle_0(SLV2NAT(Tim_min)/10) & INT2BCD_Stelle_0(SLV2NAT(Tim_min)) & char2ascii(':')
            -- Sekunden: 2-stellige BCD + ","
            -- Zeichen 63..48
            -- & char2ascii('s') & char2ascii('s') & char2ascii(',')
            & INT2BCD_Stelle_0(SLV2NAT(Tim_sec)/10) & INT2BCD_Stelle_0(SLV2NAT(Tim_sec)) & char2ascii(',')
            -- Millisekunden: 3-stellige BCD
            -- Zeichen 39..24
            --& char2ascii('t') & char2ascii('t') & char2ascii('t')
            & INT2BCD_Stelle_0(SLV2NAT(Tim_msec)/100) & INT2BCD_Stelle_0(SLV2NAT(Tim_msec)/10)
            & INT2BCD_Stelle_0(SLV2NAT(Tim_msec))
            & char2ascii(' ') & char2ascii(' ');

END LCD_Aufbereitung_architecture;
