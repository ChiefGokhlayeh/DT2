-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2004 Altera Corporation
-- Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
-- support information,  device programming or simulation file,  and any other
-- associated  documentation or information  provided by  Altera  or a partner
-- under  Altera's   Megafunction   Partnership   Program  may  be  used  only
-- to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
-- other  use  of such  megafunction  design,  netlist,  support  information,
-- device programming or simulation file,  or any other  related documentation
-- or information  is prohibited  for  any  other purpose,  including, but not
-- limited to  modification,  reverse engineering,  de-compiling, or use  with
-- any other  silicon devices,  unless such use is  explicitly  licensed under
-- a separate agreement with  Altera  or a megafunction partner.  Title to the
-- intellectual property,  including patents,  copyrights,  trademarks,  trade
-- secrets,  or maskworks,  embodied in any such megafunction design, netlist,
-- support  information,  device programming or simulation file,  or any other
-- related documentation or information provided by  Altera  or a megafunction
-- partner, remains with Altera, the megafunction partner, or their respective
-- licensors. No other licenses, including any licenses needed under any third
-- party's intellectual property, are provided herein.


-- Generated by Quartus II Version 4.2 (Build Build 157 12/07/2004)
-- Created on Thu Feb 17 08:31:41 2005

LIBRARY ieee;
USE ieee.std_logic_1164.all;

-- Hochschule Esslingen, Fakultaet IT
-- (C) 2013 R. Keller, W. Lindermeir, W. Zimmermann 

ENTITY LCD_controller IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		LCD_data : IN STD_LOGIC_VECTOR(255 downto 0);
		refresh : IN STD_LOGIC;
		reset_n : IN STD_LOGIC;
		clk_lcd : IN STD_LOGIC;
		LCD_RW : OUT STD_LOGIC;
		LCD_E : OUT STD_LOGIC;
		LCD_RS : OUT STD_LOGIC;
		LCD_ready : OUT STD_LOGIC;
		LCD_DB : INOUT STD_LOGIC_VECTOR(7 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END LCD_controller;


--  Architecture Body

ARCHITECTURE LCD_controller_architecture OF LCD_controller IS

--------------------------------------------------------------------------------------------------
-- states of main state machine
--------------------------------------------------------------------------------------------------
type main_states is (main_reset, main_idle, main_line_0, main_line_1);
signal main_state, next_main_state : main_states;

-- interface signals between main state machine and column state machine
-- output of main state machine
-- LCD_ready : std_logic; -- indicates that we are ready to receive a new screen to the higher level
signal lcd_write_line: boolean; 
signal lcd_line_number: integer range 0 to 1;
signal lcd_line_data: std_logic_vector(127 downto 0);
-- input to main state machine from column state machine
signal lcd_line_done : boolean; -- output of column state machine, input to main state machine 

-- interface signals between main state machine and lcd init state machine
-- output of main state machine
signal do_init_lcd : boolean;
-- input to main state machine from lcd init state machine
signal lcd_init_done : boolean;

--------------------------------------------------------------------------------------------------
-- states of column state machine
--------------------------------------------------------------------------------------------------
type column_states is (column_idle, column_init, 
                       column_char_0, column_char_1, column_char_2, column_char_3, column_char_4,column_char_5,
                       column_char_6,column_char_7,column_char_8,column_char_9,column_char_10,column_char_11,
                       column_char_12,column_char_13,column_char_14, column_char_15, column_char_end);
signal column_state, next_column_state : column_states;

-- interface signals between column state machine and lower level state machines (LCD_init and char_write state machines)
-- output of main state machine
-- lcd_line_done (see main state machine)
signal do_init_column: boolean; -- read by LCD_init state machine
signal do_write_char : boolean; -- read by char_write state machine
signal LCD_char_data : std_logic_vector(7 downto 0);

-- inputs to column state machine
signal column_init_done : boolean; -- from the LCD_init state machine
signal char_done : boolean; -- from the char_write state machine


--------------------------------------------------------------------------------------------------
-- states of column init state machine
--------------------------------------------------------------------------------------------------
type column_init_states is (column_init_idle, column_init_set_cursor, column_init_end);
signal column_init_state, next_column_init_state : column_init_states;

-- interface signals
-- inputs
-- do_init_column from column state machnine
-- lcd_line_no from main state machine
-- issue_done from issue state machine
-- outputs
-- column_init_done read by column state machine
signal column_command : std_logic_vector(7 downto 0); -- read by issue state machine after combination with other drivers
signal column_do_issue: boolean;                      -- read by issue state machine after combination with other drivers

--------------------------------------------------------------------------------------------------
-- states of issue command state machine
--------------------------------------------------------------------------------------------------
type issue_states is (issue_idle, issue_clear_RS_RW_E, issue_wait, issue_high_E, issue_wait_1, 
                      issue_low_E, issue_wait_2, issue_check_BF, issue_end);
signal issue_state, next_issue_state : issue_states;

-- interface signals of issue state machine
-- outputs
signal do_BF_check_from_issue  : boolean;          -- Siganl to check_BF
-- interface signals to LCD module 
signal issue_LCD_RS : std_logic;
signal issue_LCD_E  : std_logic;
signal issue_LCD_DB : std_logic_vector(7 downto 0);
signal do_wait_from_issue : boolean; -- to wait state machine do_wait
signal issue_done : boolean;
-- inputs
signal command : std_logic_vector(7 downto 0); -- from higher level
signal do_issue : boolean; -- from higher level
-- wait_done : boolean; -- from wait state machine

--------------------------------------------------------------------------------------------------
-- states of LCD init state machine
--------------------------------------------------------------------------------------------------
type lcd_init_states is (lcd_init_idle, lcd_init_reset, lcd_init_wait_0, lcd_init_func, lcd_init_lcd_off, lcd_init_wait_1,  
                      lcd_init_clear, lcd_init_mode, lcd_init_lcd_on, lcd_init_end);
signal lcd_init_state, next_lcd_init_state : lcd_init_states;

-- internal counter signal
signal lcd_init_local_counter : integer;

-- interface signals of lcd_init state machine
-- to main state machine
-- input: do_init_lcd   : boolean;
-- ouput: lcd_init_done : boolean;
signal init_command : std_logic_vector(7 downto 0); -- read by issue state machine after combination with other drivers
signal init_do_issue: boolean;                      -- read by issue state machine after combination with other drivers
signal do_wait_from_init : boolean;                 -- do_wait boolean read by wait state machine
-- input: issue_done;

--------------------------------------------------------------------------------------------------
-- states of lcd_write_char state machine
--------------------------------------------------------------------------------------------------
type lcd_write_char_states is (lcd_write_char_idle, lcd_write_char_clear_RW_E_set_RS, lcd_write_char_wait_0, lcd_write_char_set_E,
                               lcd_write_char_wait_1, lcd_write_char_clear_E, lcd_write_char_wait_2,lcd_write_char_check_BF, lcd_write_char_end); 
signal lcd_write_char_state, next_lcd_write_char_state : lcd_write_char_states;

-- interface signals of lcd_write_char state machine
-- outputs
signal do_BF_check_from_w_char : boolean; -- Signal to Check_BF
-- char_done boolean read by column state machine
signal do_wait_from_w_char : boolean; -- do_wait boolean read by wait state machine
-- interface signals to LCD Display
signal char_LCD_RS : std_logic;
signal char_LCD_E  : std_logic;
signal char_LCD_DB : std_logic_vector(7 downto 0);
-- inputs
-- LCD_char_data written by column state machine
-- do_write_char written by column state machine
-- wait_done written by wait state machine

--------------------------------------------------------------------------------------------------
-- states of wait state machine
--------------------------------------------------------------------------------------------------
constant no_wait_cycles : natural := 800; --5000;
signal wait_state, next_wait_state : integer range 0 to no_wait_cycles;

-- interface signals for wait state machine
signal do_wait   : boolean; -- from higher level
signal wait_done : boolean; -- to higher level

-------------------------------------------------------------
-- states of check_BF state machine
-------------------------------------------------------------
type check_BF_states is (check_idle, check_init, wait_20_1, read_BF, wait_20_2, wait_20_3, check_ready);

signal check_BF_state, next_check_BF_state : check_BF_states;

-- interface signals for check_bf state machine
signal do_BF_check        : boolean;  -- from higher level
signal check_done         : boolean;  -- to higher level
signal do_wait_from_check : boolean;

signal check_LCD_RS : std_logic;
signal check_LCD_RW : std_logic;
signal check_LCD_E  : std_logic;



BEGIN

--------------------------------------------------------------------------
-- driver resolution 
--------------------------------------------------------------------------
do_wait     <= do_wait_from_issue or do_wait_from_w_char or do_wait_from_init or do_wait_from_check;
command     <= init_command  or column_command;
do_issue    <= init_do_issue or column_do_issue;
do_BF_check <= do_BF_check_from_issue or do_BF_check_from_w_char;

LCD_RW   <= check_LCD_RW; 
LCD_DB   <= (issue_LCD_DB or char_LCD_DB) WHEN check_LCD_RW = '0' ELSE
            "ZZZZZZZZ";
LCD_E    <= issue_LCD_E  or char_LCD_E or check_LCD_E;
LCD_RS   <= issue_LCD_RS or char_LCD_RS or check_LCD_RS;


--------------------------------------------------------------------------
-- main state machine
--------------------------------------------------------------------------
main_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
     main_state <= main_reset;
  elsif rising_edge(clk_lcd) then
     main_state <= next_main_state;
  end if;
end process main_seq;

main_comb: process (main_state, lcd_init_done, refresh, LCD_data, lcd_line_done) is
begin
  -- next state
  case main_state is
    when main_reset   => if lcd_init_done then
                            next_main_state <= main_line_0;
                         else
                            next_main_state <= main_reset;
                         end if;
    when main_idle    => if refresh = '1' then
                            next_main_state <= main_line_0;
                         else
                            next_main_state <= main_idle;
                         end if;
    when main_line_0  => if lcd_line_done then
                            next_main_state <= main_line_1;
                         else
                            next_main_state <= main_line_0;
                         end if;
    when main_line_1  => if lcd_line_done then
                            next_main_state <= main_idle;
                         else
                            next_main_state <= main_line_1;
                         end if;
    when others       => next_main_state <= main_reset;
  end case;

  -- outputs of main state machine
  case main_state is
    when main_reset   => LCD_ready <= '0'; do_init_lcd <= true;  lcd_write_line <= false; lcd_line_number <= 0; lcd_line_data <= (others => '0');
    when main_idle    => LCD_ready <= '1'; do_init_lcd <= false; lcd_write_line <= false; lcd_line_number <= 0; lcd_line_data <= (others => '0');
    when main_line_0  => LCD_ready <= '0'; do_init_lcd <= false; lcd_write_line <= true;  lcd_line_number <= 0; lcd_line_data <= LCD_data(255 downto 128);
    when main_line_1  => LCD_ready <= '0'; do_init_lcd <= false; lcd_write_line <= true;  lcd_line_number <= 1; lcd_line_data <= LCD_data(127 downto 0);
  end case;

-- -- state debug staff
-- case main_state is
--     when main_reset   => debug_s_main <= "00";
--     when main_idle    => debug_s_main <= "01";
--     when main_line_0  => debug_s_main <= "10";
--     when main_line_1  => debug_s_main <= "11";
--  end case;
end process main_comb;


--------------------------------------------------------------------------
-- column state machine
--------------------------------------------------------------------------
column_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    column_state <= column_idle; 
  elsif rising_edge(clk_lcd) then
     column_state <= next_column_state;
  end if;
end process column_seq;

column_comb: process(column_state, lcd_write_line, lcd_line_data, column_init_done, char_done) is
begin
  -- next state
  case column_state is
    when column_idle     => if lcd_write_line then
                              next_column_state <= column_init;
                            else
                              next_column_state <= column_idle;
                            end if;
    when column_init     => if column_init_done then
                              next_column_state <= column_char_0;
                            else
                              next_column_state <= column_init;
                            end if;
    when column_char_0   => if char_done then
                              next_column_state <= column_char_1;
                            else
                              next_column_state <= column_char_0;
                            end if;
    when column_char_1   => if char_done then
                              next_column_state <= column_char_2;
                            else
                              next_column_state <= column_char_1;
                            end if;
    when column_char_2   => if char_done then
                              next_column_state <= column_char_3;
                            else
                              next_column_state <= column_char_2;
                            end if;
    when column_char_3   => if char_done then
                              next_column_state <= column_char_4;
                            else
                              next_column_state <= column_char_3;
                            end if;
    when column_char_4   => if char_done then
                              next_column_state <= column_char_5;
                            else
                              next_column_state <= column_char_4;
                            end if;
    when column_char_5   => if char_done then
                              next_column_state <= column_char_6;
                            else
                              next_column_state <= column_char_5;
                            end if;
    when column_char_6   => if char_done then
                              next_column_state <= column_char_7;
                            else
                              next_column_state <= column_char_6;
                            end if;
    when column_char_7   => if char_done then
                              next_column_state <= column_char_8;
                            else
                              next_column_state <= column_char_7;
                            end if;
    when column_char_8   => if char_done then
                              next_column_state <= column_char_9;
                            else
                              next_column_state <= column_char_8;
                            end if;
    when column_char_9   => if char_done then
                              next_column_state <= column_char_10;
                            else
                              next_column_state <= column_char_9;
                            end if;
    when column_char_10  => if char_done then
                              next_column_state <= column_char_11;
                            else
                              next_column_state <= column_char_10;
                            end if;
    when column_char_11  => if char_done then
                              next_column_state <= column_char_12;
                            else
                              next_column_state <= column_char_11;
                            end if;
    when column_char_12  => if char_done then
                              next_column_state <= column_char_13;
                            else
                              next_column_state <= column_char_12;
                            end if;
    when column_char_13  => if char_done then
                              next_column_state <= column_char_14;
                            else
                              next_column_state <= column_char_13;
                            end if;
    when column_char_14  => if char_done then
                              next_column_state <= column_char_15;
                            else
                              next_column_state <= column_char_14;
                            end if;
    when column_char_15  => if char_done then
                              next_column_state <= column_char_end;
                            else
                              next_column_state <= column_char_15;
                            end if;
    when column_char_end => next_column_state <= column_idle;
    when others          => next_column_state <= column_idle;
  end case;


  -- output of column state machine
  case column_state is
    when column_idle     => lcd_line_done <= false; do_init_column<= false; do_write_char <= false; LCD_char_data <= (others => '0');
    when column_init     => lcd_line_done <= false; do_init_column<= true;  do_write_char <= false; LCD_char_data <= (others => '0');
    when column_char_0   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data(127 downto 127-7);
    when column_char_1   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data(119 downto 119-7);
    when column_char_2   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data(111 downto 111-7);
    when column_char_3   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data(103 downto 103-7);
    when column_char_4   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 95 downto  95-7);
    when column_char_5   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 87 downto  87-7);
    when column_char_6   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 79 downto  79-7);
    when column_char_7   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 71 downto  71-7);
    when column_char_8   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 63 downto  63-7);
    when column_char_9   => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 55 downto  55-7);
    when column_char_10  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 47 downto  47-7);
    when column_char_11  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 39 downto  39-7);
    when column_char_12  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 31 downto  31-7);
    when column_char_13  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 23 downto  23-7);
    when column_char_14  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data( 15 downto  15-7);
    when column_char_15  => lcd_line_done <= false; do_init_column<= false; do_write_char <= true;  LCD_char_data <= lcd_line_data(  7 downto   7-7);
    when column_char_end => lcd_line_done <= true;  do_init_column<= false; do_write_char <= false; LCD_char_data <= (others => '0');
  end case;

--   -- state debug staff
--   case column_state is
--     when column_idle     => debug_s_column <= "00000";
--     when column_init     => debug_s_column <= "00001";
--     when column_char_0   => debug_s_column <= "00010";
--     when column_char_1   => debug_s_column <= "00011";
--     when column_char_2   => debug_s_column <= "00100";
--     when column_char_3   => debug_s_column <= "00101";
--     when column_char_4   => debug_s_column <= "00110";
--     when column_char_5   => debug_s_column <= "00111";
--     when column_char_6   => debug_s_column <= "01000";
--     when column_char_7   => debug_s_column <= "01001";
--     when column_char_8   => debug_s_column <= "01010";
--     when column_char_9   => debug_s_column <= "01011";
--     when column_char_10  => debug_s_column <= "01100";
--     when column_char_11  => debug_s_column <= "01101";
--     when column_char_12  => debug_s_column <= "01110";
--     when column_char_13  => debug_s_column <= "01111";
--     when column_char_14  => debug_s_column <= "10000";
--     when column_char_15  => debug_s_column <= "10001";
--     when column_char_end => debug_s_column <= "10010";
--  end case;
end process column_comb;




--------------------------------------------------------------------------------------------------
-- column init state machine
--------------------------------------------------------------------------------------------------
column_init_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    column_init_state <= column_init_idle; 
  elsif rising_edge(clk_lcd) then
     column_init_state <= next_column_init_state;
  end if;
end process column_init_seq;


column_init_comb: process(column_init_state, do_init_column, lcd_line_number, issue_done) is
variable local_cmd : std_logic_vector(7 downto 0);
begin
  -- next state
  case column_init_state is
    when column_init_idle       => if do_init_column then
                                     next_column_init_state <= column_init_set_cursor;
                                   else
                                     next_column_init_state <= column_init_idle;
                                   end if;
    when column_init_set_cursor => if issue_done then
                                     next_column_init_state <= column_init_end;
                                   else
                                     next_column_init_state <= column_init_set_cursor;
                                   end if;
    when column_init_end        => next_column_init_state <= column_init_idle;
    when others                 => next_column_init_state <= column_init_idle;
  end case;

  -- set cursor address
  if lcd_line_number = 0 then
     local_cmd := "10000000";
  else
     local_cmd := "11000000";
  end if;

  -- output signals
  case column_init_state is
    when column_init_idle       => column_init_done <= false; column_command <= "00000000"; column_do_issue <= false;
    when column_init_set_cursor => column_init_done <= false; column_command <= local_cmd;  column_do_issue <= true;
    when column_init_end        => column_init_done <= true;  column_command <= "00000000"; column_do_issue <= false;
  end case;

--   -- state debug staff
--   case column_init_state is
--     when column_init_idle       => debug_s_column_init <= "00";
--     when column_init_set_cursor => debug_s_column_init <= "01";
--     when column_init_end        => debug_s_column_init <= "10";
--   end case;

end process column_init_comb;


--------------------------------------------------------------------------------------------------
-- issue command state machine
--------------------------------------------------------------------------------------------------

issue_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    issue_state <= issue_idle; 
  elsif rising_edge(clk_lcd) then
     issue_state <= next_issue_state;
  end if;
end process issue_seq;

issue_comb: process(issue_state, wait_done, check_done, do_issue, command) is
begin
  -- next state
  case issue_state is
    when issue_idle          => if do_issue then
                                  next_issue_state <= issue_clear_RS_RW_E;
                                else
                                  next_issue_state <= issue_idle;
                                end if;
    when issue_clear_RS_RW_E => next_issue_state <= issue_wait;
    when issue_wait          => if wait_done then
                                  next_issue_state <= issue_high_E;
                                else
                                  next_issue_state <= issue_wait;
                                end if;
    when issue_high_E        => next_issue_state <= issue_wait_1;
    when issue_wait_1        => if wait_done then
                                  next_issue_state <= issue_low_E;
                                else
                                  next_issue_state <= issue_wait_1;
                                end if;
    when issue_low_E         => next_issue_state <= issue_wait_2;
    when issue_wait_2        => if wait_done then
                                  next_issue_state <= issue_check_BF;
                                else
                                  next_issue_state <= issue_wait_2;
                                end if;
    when issue_check_BF      => if check_done then
                                  next_issue_state <= issue_end;
                               else
                                  next_issue_state <= issue_check_BF;
                               end if;
    when issue_end           => next_issue_state <= issue_idle;
    when others              => next_issue_state <= issue_idle;
  end case;

  -- output signals
  case issue_state is
    when issue_idle          => issue_done <= false; do_wait_from_issue <= false; do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= (others => '0'); 
    when issue_clear_RS_RW_E => issue_done <= false; do_wait_from_issue <= false; do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
    when issue_wait          => issue_done <= false; do_wait_from_issue <= true;  do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
    when issue_high_E        => issue_done <= false; do_wait_from_issue <= false; do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '1'; issue_LCD_DB <= command;         
    when issue_wait_1        => issue_done <= false; do_wait_from_issue <= true;  do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '1'; issue_LCD_DB <= command;         
    when issue_low_E         => issue_done <= false; do_wait_from_issue <= false; do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
    when issue_wait_2        => issue_done <= false; do_wait_from_issue <= true;  do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
    when issue_check_BF      => issue_done <= false; do_wait_from_issue <= false; do_BF_check_from_issue <= true;  issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
    when issue_end           => issue_done <= true;  do_wait_from_issue <= false; do_BF_check_from_issue <= false; issue_LCD_RS <= '0'; issue_LCD_E <= '0'; issue_LCD_DB <= command;         
  end case;

--   -- state debug staff
--   case issue_state is
--     when issue_idle          => debug_s_issue <= "0000";
--     when issue_clear_RS_RW_E => debug_s_issue <= "0001";
--     when issue_wait          => debug_s_issue <= "0010";
--     when issue_high_E        => debug_s_issue <= "0011";
--     when issue_wait_1        => debug_s_issue <= "0100";
--     when issue_low_E         => debug_s_issue <= "0101";
--     when issue_wait_2        => debug_s_issue <= "0110";
--     when issue_check_BF      => debug_s_issue <= "0111";
--     when issue_end           => debug_s_issue <= "1000";
--  end case;

end process issue_comb;


--------------------------------------------------------------------------------------------------
-- LCD init state machine
--------------------------------------------------------------------------------------------------
lcd_init_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    lcd_init_state <= lcd_init_idle; 
  elsif rising_edge(clk_lcd) then
     lcd_init_state <= next_lcd_init_state;

     -- local counter update on edge condition: decrement on transition from lcd_init_reset to lcd_init_wait_0
     if lcd_init_state = lcd_init_idle then
       lcd_init_local_counter <= 3;
     elsif next_lcd_init_state = lcd_init_wait_0 and lcd_init_state = lcd_init_reset then
       lcd_init_local_counter <= lcd_init_local_counter-1; 
     end if;
  end if;
end process lcd_init_seq;


lcd_init_comb: process(lcd_init_state, do_init_lcd, issue_done, wait_done, lcd_init_local_counter) is
begin
  -- next state
  case lcd_init_state is
    when lcd_init_idle    => if do_init_lcd then
                               next_lcd_init_state <= lcd_init_reset;
                             else
                               next_lcd_init_state <= lcd_init_idle;
                             end if;
    when lcd_init_reset   => if issue_done then
                               next_lcd_init_state <= lcd_init_wait_0;
                             else
                               next_lcd_init_state <= lcd_init_reset;
                             end if;
    when lcd_init_wait_0  => if not wait_done then
                               next_lcd_init_state <= lcd_init_wait_0;
                             elsif lcd_init_local_counter /= 0 then
                               next_lcd_init_state <= lcd_init_reset;
                             else 
                               next_lcd_init_state <= lcd_init_func;
                             end if;
    when lcd_init_func    => if issue_done then
                               next_lcd_init_state <= lcd_init_lcd_off;
                             else
                               next_lcd_init_state <= lcd_init_func;
                             end if;
    when lcd_init_lcd_off => if issue_done then
                               next_lcd_init_state <= lcd_init_wait_1;
                             else
                               next_lcd_init_state <= lcd_init_lcd_off;
                             end if;
    when lcd_init_wait_1  => if wait_done then
                               next_lcd_init_state <= lcd_init_clear;
                             else
                               next_lcd_init_state <= lcd_init_wait_1;
                             end if;
    when lcd_init_clear   => if issue_done then
                               next_lcd_init_state <= lcd_init_mode;
                             else
                               next_lcd_init_state <= lcd_init_clear;
                             end if;
    when lcd_init_mode    => if issue_done then
                               next_lcd_init_state <= lcd_init_lcd_on;
                             else
                               next_lcd_init_state <= lcd_init_mode;
                             end if;
    when lcd_init_lcd_on  => if issue_done then
                               next_lcd_init_state <= lcd_init_end;
                             else
                               next_lcd_init_state <= lcd_init_lcd_on;
                             end if;
    when lcd_init_end     => next_lcd_init_state <= lcd_init_idle;
    when others           => next_lcd_init_state <= lcd_init_idle;
  end case;

  -- output from init state machine
  case lcd_init_state is
    when lcd_init_idle    => lcd_init_done <= false; init_command <= "00000000"; init_do_issue <= false; do_wait_from_init <= false;
    when lcd_init_reset   => lcd_init_done <= false; init_command <= "00110000"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_wait_0  => lcd_init_done <= false; init_command <= "00000000"; init_do_issue <= false; do_wait_from_init <= true;
    when lcd_init_func    => lcd_init_done <= false; init_command <= "00111000"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_lcd_off => lcd_init_done <= false; init_command <= "00001000"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_wait_1  => lcd_init_done <= false; init_command <= "00000000"; init_do_issue <= false; do_wait_from_init <= true;
    when lcd_init_clear   => lcd_init_done <= false; init_command <= "00000001"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_mode    => lcd_init_done <= false; init_command <= "00000110"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_lcd_on  => lcd_init_done <= false; init_command <= "00001100"; init_do_issue <= true;  do_wait_from_init <= false;
    when lcd_init_end     => lcd_init_done <= true;  init_command <= "00000000"; init_do_issue <= false; do_wait_from_init <= false;
  end case;

--   -- state debug staff
--   case lcd_init_state is
--     when lcd_init_idle    => debug_s_init <= "0000";
--     when lcd_init_reset   => debug_s_init <= "0001";
--     when lcd_init_wait_0  => debug_s_init <= "0010";
--     when lcd_init_func    => debug_s_init <= "0011";
--     when lcd_init_lcd_off => debug_s_init <= "0100";
--     when lcd_init_wait_1  => debug_s_init <= "0101";
--     when lcd_init_clear   => debug_s_init <= "0110";
--     when lcd_init_mode    => debug_s_init <= "0111";
--     when lcd_init_lcd_on  => debug_s_init <= "1000";
--     when lcd_init_end     => debug_s_init <= "1001";
--   end case;
end process lcd_init_comb;

--------------------------------------------------------------------------------------------------
-- lcd_write_char state machine
--------------------------------------------------------------------------------------------------
lcd_write_char_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    lcd_write_char_state <= lcd_write_char_idle; 
  elsif rising_edge(clk_lcd) then
     lcd_write_char_state <= next_lcd_write_char_state;
  end if;
end process lcd_write_char_seq;

lcd_write_char_comb: process(lcd_write_char_state, LCD_char_data, do_write_char, wait_done, check_done) is
begin
  -- next state
  case lcd_write_char_state is
    when lcd_write_char_idle              => if do_write_char then
                                               next_lcd_write_char_state <= lcd_write_char_clear_RW_E_set_RS;
                                             else
                                               next_lcd_write_char_state <= lcd_write_char_idle;
                                             end if;
    when lcd_write_char_clear_RW_E_set_RS => next_lcd_write_char_state <= lcd_write_char_wait_0;
    when lcd_write_char_wait_0            => if wait_done then
                                               next_lcd_write_char_state <= lcd_write_char_set_E;
                                             else
                                               next_lcd_write_char_state <= lcd_write_char_wait_0;
                                             end if;
    when lcd_write_char_set_E             => next_lcd_write_char_state <= lcd_write_char_wait_1;
    when lcd_write_char_wait_1            => if wait_done then
                                               next_lcd_write_char_state <= lcd_write_char_clear_E;
                                             else
                                               next_lcd_write_char_state <= lcd_write_char_wait_1;
                                             end if;
    when lcd_write_char_clear_E           => next_lcd_write_char_state <= lcd_write_char_wait_2;
    when lcd_write_char_wait_2            => if wait_done then
                                               next_lcd_write_char_state <= lcd_write_char_check_BF;
                                             else
                                               next_lcd_write_char_state <= lcd_write_char_wait_2;
                                             end if;
    when lcd_write_char_check_BF          => if check_done then
                                               next_lcd_write_char_state <= lcd_write_char_end;
                                             else
                                               next_lcd_write_char_state <= lcd_write_char_check_BF;
                                             end if;
    when lcd_write_char_end               => next_lcd_write_char_state <= lcd_write_char_idle;
    when others                           => next_lcd_write_char_state <= lcd_write_char_idle;
  end case;

  -- output signals
  case lcd_write_char_state is
    when lcd_write_char_idle              => char_done <= false;  do_wait_from_w_char <= false; do_BF_check_from_w_char <= false; char_LCD_RS <= '0'; char_LCD_E <= '0'; char_LCD_DB <= (others => '0');
    when lcd_write_char_clear_RW_E_set_RS => char_done <= false;  do_wait_from_w_char <= false; do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_wait_0            => char_done <= false;  do_wait_from_w_char <= true;  do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_set_E             => char_done <= false;  do_wait_from_w_char <= false; do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '1'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_wait_1            => char_done <= false;  do_wait_from_w_char <= true;  do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '1'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_clear_E           => char_done <= false;  do_wait_from_w_char <= false; do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_wait_2            => char_done <= false;  do_wait_from_w_char <= true;  do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_check_BF          => char_done <= false;  do_wait_from_w_char <= false; do_BF_check_from_w_char <= true; char_LCD_RS <= '0'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
    when lcd_write_char_end               => char_done <= true;   do_wait_from_w_char <= false; do_BF_check_from_w_char <= false; char_LCD_RS <= '1'; char_LCD_E <= '0'; char_LCD_DB <= LCD_char_data;
  end case;

--  -- state debug staff
--   case lcd_write_char_state is
--     when lcd_write_char_idle              => debug_s_char <= "0000";
--     when lcd_write_char_clear_RW_E_set_RS => debug_s_char <= "0001";
--     when lcd_write_char_wait_0            => debug_s_char <= "0010";
--     when lcd_write_char_set_E             => debug_s_char <= "0011";
--     when lcd_write_char_wait_1            => debug_s_char <= "0100";
--     when lcd_write_char_clear_E           => debug_s_char <= "0101";
--     when lcd_write_char_wait_2            => debug_s_char <= "0110";
--     when lcd_write_char_check_BF          => debug_s_char <= "0111";
--     when lcd_write_char_end               => debug_s_char <= "1000";
--  end case;
end process lcd_write_char_comb;



--------------------------------------------------------------------------
-- wait state machine
--------------------------------------------------------------------------
wait_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    wait_state <= 0; 
  elsif rising_edge(clk_lcd) then
     wait_state <= next_wait_state;
  end if;
end process wait_seq;

wait_comb: process(wait_state, do_wait) is
begin
  -- next state
  if wait_state = 0 then        -- here we are idle
       if do_wait then
         next_wait_state <= 1;  -- start the machine
       else
         next_wait_state <= 0;
       end if;
  elsif wait_state >= no_wait_cycles then
       next_wait_state <= 0;  -- we are done
  else 
       next_wait_state <= wait_state + 1;  
  end if;
         
  -- output signals
  if wait_state = no_wait_cycles then
     wait_done <= true;
  else
     wait_done <= false;
  end if;

end process wait_comb;


--------------------------------------------------------------------------
-- check_BF state machine
--------------------------------------------------------------------------
check_BF_seq: process (clk_lcd, reset_n) is
begin
  if reset_n = '0' then
     -- reset condition
    check_BF_state <= check_idle; 
  elsif rising_edge(clk_lcd) then
     check_BF_state  <= next_check_BF_state;
  end if;
end process check_BF_seq;

check_comb: process(check_BF_state, do_BF_check, LCD_DB, wait_done) is
begin
        --next state:
        case check_BF_state is
                when check_idle  =>  if do_BF_check then
                                       next_check_BF_state <= check_init;
                                     else
                                       next_check_BF_state <= check_idle;
                                     end if;
                when check_init  =>  next_check_BF_state <= wait_20_1;
                when wait_20_1   =>  if wait_done then                
                                       next_check_BF_state <= read_BF;   
                                     else                            
                                       next_check_BF_state <= wait_20_1; 
                                     end if;                          
                when read_BF     =>  if LCD_DB(7) = '1' then                 -- LCD busy
                                       next_check_BF_state <= wait_20_2;   
                                     else                            
                                       next_check_BF_state <= check_ready;
                                     end if;                          
                when wait_20_2   =>  if wait_done then
                                       next_check_BF_state <= wait_20_3;   
                                     else
                                       next_check_BF_state <= wait_20_2;     -- continue wait
                                     end if;                          
                when wait_20_3   =>  if wait_done then                
                                       next_check_BF_state <= check_init;   
                                     else                            
                                       next_check_BF_state <= wait_20_3; 
                                     end if;                          
                when check_ready =>  next_check_BF_state <= check_idle;
                when others      =>  next_check_BF_state <= check_idle;
        end case;

        --outputs:
        case check_BF_state is
                when check_idle  => check_done <= false; do_wait_from_check <= false; check_LCD_RS <= '0'; check_LCD_RW <='0'; check_LCD_E <= '0'; 
                when check_init  => check_done <= false; do_wait_from_check <= false; check_LCD_RS <= '0'; check_LCD_RW <='1'; check_LCD_E <= '0'; 
                when wait_20_1   => check_done <= false; do_wait_from_check <= true;  check_LCD_RS <= '0'; check_LCD_RW <='1'; check_LCD_E <= '1';
                when read_BF     => check_done <= false; do_wait_from_check <= false; check_LCD_RS <= '0'; check_LCD_RW <='1'; check_LCD_E <= '1';
                when wait_20_2   => check_done <= false; do_wait_from_check <= true;  check_LCD_RS <= '0'; check_LCD_RW <='0'; check_LCD_E <= '0'; 
                when wait_20_3   => check_done <= false; do_wait_from_check <= true;  check_LCD_RS <= '0'; check_LCD_RW <='1'; check_LCD_E <= '1'; 
                when check_ready => check_done <= true;  do_wait_from_check <= false; check_LCD_RS <= '0'; check_LCD_RW <='1'; check_LCD_E <= '0'; 
                when others      => check_done <= false; do_wait_from_check <= false; check_LCD_RS <= '0'; check_LCD_RW <='0'; check_LCD_E <= '0'; 
        end case;                

--  -- state debug staff
--   case check_BF_state is
--                when check_idle  =>        debug_s_check_BF <= "000";
--                when check_init  =>        debug_s_check_BF <= "001";
--                when wait_20_1   =>        debug_s_check_BF <= "010";
--                when read_BF     =>        debug_s_check_BF <= "011";
--                when wait_20_2   =>        debug_s_check_BF <= "100";
--                when wait_20_3   =>        debug_s_check_BF <= "101";
--                when check_ready =>        debug_s_check_BF <= "110";
--                when others      =>        debug_s_check_BF <= "111";
--   end case;                

end process check_comb;


END LCD_controller_architecture;
